<!DOCTYPE html><html><head><meta charset="UTF-8" /><title>2023-05-15 / journals / Jake Chvatal</title><meta content="width=device-width,initial-scale=1.0" name="viewport" /><meta content="2023-05-15" property="og:title" /><meta content="website" property="og:type" /><meta content="https://jake.isnt.online" property="og:url" /><meta content="Jake Chvatal" property="og:site_name" /><meta content="hi" name="description" /><meta content="Operating Systems, webring, programming, languages" name="keywords" /><meta content="Jake Chvatal" name="author" /><meta content="index,follow" name="robots" /><meta content="white" media="(prefers-color-scheme: light)" name="theme-color" /><meta content="#111" media="(prefers-color-scheme: dark)" name="theme-color" /><link href="/favicon/apple-touch-icon.png" rel="apple-touch-icon" /><link href="/manifest.json" rel="manifest" /><link href="/style.css" id="/style.css" rel="stylesheet" type="text/css" /><link href="/global.css" id="/global.css" rel="stylesheet" type="text/css" /><script id="/lib.js" src="/lib.js"></script><link href="/elements.css" id="/elements.css" rel="stylesheet" type="text/css" /><script defer="defer" id="/elements.js" src="/elements.js"></script><script defer="defer" src="https://unpkg.com/@highlightjs/cdn-assets@11.7.0/highlight.min.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/base16/nord.min.css" rel="stylesheet" /></head><body><div class="sidebar"><div class="url-path"><a href="/">jake.</a><a href="https://isnt.online"> ~ </a><span> / </span><a href="./index.html">journals</a><span> / </span><b>2023-05-15</b><link href="/components/sidebar/sidebar.css" id="/components/sidebar/sidebar.css" rel="stylesheet" type="text/css" /></div><span><div class="toggle-dark-mode-container"><button class="toggle-dark-mode"></button></div><script id="/components/toggle-dark-mode/toggle-dark-mode.js" src="/components/toggle-dark-mode/toggle-dark-mode.js"></script><link href="/components/toggle-dark-mode/toggle-dark-mode.css" id="/components/toggle-dark-mode/toggle-dark-mode.css" rel="stylesheet" type="text/css" /></span></div><div class="site-body"><main><article class="wikipage"><h1 class="title-top">2023-05-15</h1><div><ul><li>Monday, 05/15/2023** 18:06What am I doing right now?</li></ul><ul><li>Package up returns</li><li>Put clothes in a pile to get rid of</li><li>Edit a photo</li><li>Render a square of pixels on the screen with raylib and change them every second</li><li>Make a plan for lunchboxes** 22:15Today I've been radicalized by GPUs. I've spent my life up until this point assuming that graphics libraries all start and end with turning pixels on the screen on and off. This is just not true.</li></ul><p>The short of it is that the GPU on your computer - either 'integrated' (built into the CPU as an optimised subsection) or  'discrete' (a separate card entirely) hold a data structure called a framebuffer that represents the pixels that will be written to the screen. This information is written to a buffer then sent to the screen. The framebuffer is a data structure that represents the pixels of a monitor.</p><p>Cool, so I can just turn pixels on the framebuffer on and off?</p><p>No.</p><p>First, the framebuffer isn't just exposed. Whatever windowing system you're using does not allow you to write to the framebuffer at will. That would be a security vulnerability at best - applications could write pixels into one another to make you see something - and at worst make your computer unusable without a standard protocol that tells them how to write to the framebuffer and where. (If you aren't in a graphical session, you can get raw access to the framebuffer: https://seenaburns.com/2018/04/04/writing-to-the-framebuffer/).</p><p>You'll want to use a windowing library that abstracts requesting this framebuffer for you over various windowing systems (as Windows, MacOS, etc. have all concocted slightly different ways of doing this, nad they love making extra work for programmers) and gives you a reference to it. GLFW is historically the most popular, but systems like SDL2 and winit (Rust) provide similar functionality. You can then write pixels to this buffer following a standard, straightforward protocol nad they'll show up on the screen.</p><p>Unfortunately, though, the framebuffer doesn't live on the CPU or in the screen or whatever you think would be sane. Yes, screens have framebuffers, but it's your operating system's job to mediate between its representation and the data the screen is given. It lives on the GPU. GPUs are not optimized for drawing pixels on screens. They're complex mathematical hardware with complex APIs, optimized for rendering lines and rays and curves for modern 3D graphics, originally created to optimize for rendering perfect fonts with PostScript rather than in a bitwise fashion. The good news: they make playing video games fast, performing complex application tasks in parallel. How they do this is to be learned and probably under NDA. The bad news: GPUs expose complex, proprietary APIs that are inelegant and expose very large surface areas to program against. This makes learning to program for optimal graphics a mess, mostly because you're protecting corporate secrets. CUDA - the fundamental API exposed to empower parallel programming on the GPU - is not open. This makes computing a complex, ugly, mess - you'll always be programming against this nasty, abstracted API that's been artificially created, rather than being able to write to the machine and have the machine just render the text. This makes leveraging modern computing power a disgusting mess.</p><p>The good news here is that you can just ask GLFW for a reference to the framebuffer and write to it.</p><p>My goal with learning computer graphics has been to build small, beautiful applications that people - people who don't know much at all about using computers - can use every day to accomplish things in their life more seamlessly. Two paths to move forward:</p><ol><li>Learn to implement graphics tools by pretending modern graphics don't work that way and start developing abstractions over the framebuffer.</li><li>Commit to learning a modern graphics library or abstraction. WebGPU and Vulkan are both compelling ways forward here. Vulkan has a solid Linux compatibility layer and is guaranteed Windows/Linux/other platform support. Metal (classic proprietary MacOS work) is DOA. WebGPU is incredibly compelling but the API doesn't have sustainability guarantees. It's made for the browser - so it's made to run anywhere and everywhere - but the API could be a moving target.</li></ol><p>Whoah - Mach Engine solved this. https://github.com/hexops/mach-gpu.</p></div></article></main><div class="git-hist-table"><table><tbody><tr><td class="commit-date-tr">2023-05-15</td><td class="commit-link-tr"><a href="https://github.com/jakeisnt/wiki/blob/df77b9b42b4cdeeb4b6d0212bfaf40f2679f919e//journals/2023-05-15.md">df77b9b4</a></td></tr></tbody></table></div></div></body></html>