<!DOCTYPE html><html><head><meta charset="UTF-8" /><title>2021-01-04 / journals / Jake Chvatal</title><meta content="width=device-width,initial-scale=1.0" name="viewport" /><meta content="2021-01-04" property="og:title" /><meta content="website" property="og:type" /><meta content="https://jake.isnt.online" property="og:url" /><meta content="Jake Chvatal" property="og:site_name" /><meta content="hi" name="description" /><meta content="Operating Systems, webring, programming, languages" name="keywords" /><meta content="Jake Chvatal" name="author" /><meta content="index,follow" name="robots" /><meta content="white" media="(prefers-color-scheme: light)" name="theme-color" /><meta content="#111" media="(prefers-color-scheme: dark)" name="theme-color" /><link href="/favicon/apple-touch-icon.png" rel="apple-touch-icon" /><link href="/manifest.json" rel="manifest" /><link href="/style.css" id="/style.css" rel="stylesheet" type="text/css" /><link href="/global.css" id="/global.css" rel="stylesheet" type="text/css" /><script id="/lib.js" src="/lib.js"></script><link href="/elements.css" id="/elements.css" rel="stylesheet" type="text/css" /><script defer="defer" id="/elements.js" src="/elements.js"></script><script defer="defer" id="https://unpkg.com/@highlightjs/cdn-assets@11.7.0/highlight.min.js" src="https://unpkg.com/@highlightjs/cdn-assets@11.7.0/highlight.min.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/nord.min.css" id="dark-theme-highlight" rel="stylesheet" /><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-light.min.css" id="light-theme-highlight" rel="stylesheet" /></head><body><div class="sidebar"><div class="url-path"><a href="/">jake.</a><a href="https://isnt.online"> ~ </a><span> / </span><a href="./index.html">journals</a><span> / </span><b>2021-01-04</b><link href="/components/sidebar/sidebar.css" id="/components/sidebar/sidebar.css" rel="stylesheet" type="text/css" /></div><span><div class="toggle-dark-mode-container"><button class="toggle-dark-mode"></button></div><script defer="defer" id="/components/toggle-dark-mode/toggle-dark-mode.js" src="/components/toggle-dark-mode/toggle-dark-mode.js"></script><link href="/components/toggle-dark-mode/toggle-dark-mode.css" id="/components/toggle-dark-mode/toggle-dark-mode.css" rel="stylesheet" type="text/css" /></span></div><div class="site-body"><main><article class="wikipage"><h1 class="title-top">2021-01-04</h1><div><h2 id="1600-various-thoughts">16:00 various thoughts</h2><h3 id="whats-wrong-with-posix-io">what's wrong with posix io</h3><p><a href="https://www.nextplatform.com/2017/09/11/whats-bad-posix-io/">src</a></p><ul><li>stateful: file descriptors must always be opened before reading orwriting them, but this is all tracked internal to the kernel ratherthan externally; this measn that things can't be done asynchronously</li><li>the posix io model causes the cost of opening a file to scale linearlywith the number of requests in userland requesting the opening, <em>even</em>on parallel file systems!</li><li><p>prescribing metadata doesn't seem all that bad… their point is thatfiles are all kept track of independently but still must maintain thesame standards. this cannot adapt to additional metadata informationwe want to store</p><ul><li>isn't it fine to just use extra files to denote additional specs?you can use the <em>format</em> of the file to carry that additionalinformation, or manage it in other files as metadata. perhapsanother system may want to track extra information… in this case,the separation is not quite ideal, but this does not seem like asignificant issue</li></ul></li><li><p>semantics: after a write, each read returns the data specified by theprevious write until the next write. this means that a write isrequired to block execution until a read call will produce the resultfrom that write, which is grossly inneficient for async systems - butit provides strong guarantees to those systems, and without thisguarantee you'd have to check back to see if the file was updated whenmonitoring files</p><p><a href="http://doc.lustre.org/lustre_manual.xhtml#dbdoclet.50438206_86244">reduces consistency to a singlenode</a><a href="http://docs.cray.com/books/S-0005-5204/S-0005-5204.pdf">relaxes stateful requirements of paralleldata</a></p><p>i don't think this article was quite meant for my work - in my world,the POSIX guarantees provided are better than alternatives. they'restandards that provide guarantees I do think that certaintechnologies - synchronous requirements for linting, for example -that I use could be done asynchronously more effectively, but the realsolution here is not to serialize out to files at all. programmingshouldn't be about the file, it should be about the program!</p></li></ul><h3 id="partial-rebuttal-of-the-previous-by-robb-a-plan9-author">partial rebuttal of the previous by robb, a plan9 author</h3><p><a href="http://harmful.cat-v.org/software/andy_tanenbaum">src</a></p><ul><li>microkernels may not be the way to go for consumer software; plan9'skernel is much smaller than the linux kernel or any distributedsystem. \[perhaps a monolithic kernel isn't the best for abstraction,but it offers much more compact functionality and better performance\]</li><li>unix as an application program? seems like an emulation layer that'sway too difficult to approach</li><li>enabling RPC but leaving it to the user to implement is silly andterrible. having to implement RPC standards for every userland programruins the consistency of the system and any power necessary tomaintain it</li><li>async is not the answer to synchronous inneficiencies. they solvedifferent problems!</li><li>new languages are needed – they say no, but 29 years later i think theanswer is an obvious yes – it's the lack of programming languagedevelopment and higher level features, particularly in systemsprogramming, that has hurt the user of such programs. languages likerust have carried a lot of the systems programming development, thoughits fixation with the imperfect LLVM</li><li>distributed shared memory diss - i kind of agree</li><li>if you have a good <em>process</em> model, you can ignore all of theseprocess/thread distinctions and substantially simplify the machine.having both is a substantial flaw.</li></ul><h3 id="the-reddit-thread-about-rewriting-unix-like">the reddit thread about rewriting unix-like</h3><p><a href="https://www.reddit.com/r/linux/comments/kq4cet/if_a_linuxunix_was_rewritten_today_what_would_be/">src</a></p><ul><li>the user system was designed to protect the system from users ratherthan protecting users from malicious software, as is more often thecase today. there are mitigations - 'hacks' like running each program'in a container' with an isolated file system and new user, but thisis a stopgap measure. proper single user environments should see realimplementations; we don't share computers or systems as much assomeone computing before the 80s would anticipate</li><li><a href="https://www.youtube.com/watch?v=ZwjzfdLJtX4">cool video from leonardpottering</a> – making theuser's data independent from the operating system means that you don'thave to worry about reinstalling over it.</li><li>config files need better and improved standards</li><li>a standard way of parsing and returning command line inputs! if youstandardize that <em>in the kernel</em>, then user programs trivially have tosupport identical interfaces! \[there isn't that much space forcreativity on the command line anyways…\]</li><li>shifting responsibility to things the user can't modify to guaranteeconsistency is excellent when done right - that is, when it's clearthat there is a solution that will be liked or at least generallyaccepted. <a href="https://wiki.amigaos.net/wiki/Basic_Input_and_Output_Programming#Standard_Command_Line_Parsing">see the amigaosdocs</a><a href="https://clig.dev/">and command line standards document</a></li><li>look into the selinux/apparmor permissions systems, just like what'simplemented in android. these properly 'fix' the mermissions we havein mainline linux systems</li></ul><p>cool things about languages:</p><ul><li>nim: completely c interoperable; nimscript handles a lot</li><li>zig: lightweight and memory safe</li><li>rust: takes a significant amount of time to learn, a bit bloated, buta powerhouse and a joy to program in – particularly functionally</li></ul><p>the obvious one: why is piping plain text in and out the basis for anoperating system? did ken thompson hate OO that much? microkernels arejust better for software though, right?</p><p>learn more about redox; it will be beneficial for the future<a href="https://doc.redox-os.org/book/ch01-05-why-redox.html">https://doc.redox-os.org/book/ch01-05-why-redox.html</a> <a href="../pages/os.org">OperatingSystems</a><a href="https://scattered-thoughts.net/writing/assorted-thoughts-on-zig-and-rust/">https://scattered-thoughts.net/writing/assorted-thoughts-on-zig-and-rust/</a>zig seems significantly easier to learn than rust while offering similarsecurity, for the most part. it also seems to offer some ml style power,albeit without the syntax</p><p>zig compilation is lazy, has very good support for cross-compilation.cool build system that differs from cargo and allows for the creation ofarbitrary build systems</p><p>zig has much lower cognitive overhead than rust, and seems better forfaster development speed, but it doesnt have a good method for uafescalation, data races, data sharing etc. rust lifetimes are cool and soare traits, but zig might have the facilities to implement them</p><p><a href="https://en.wikipedia.org/wiki/Inferno_(operating_system)">https://en.wikipedia.org/wiki/Inferno_(operating_system)</a> sequel toplan9 - it even runs as a userspace application inside of the plan9operating system. the fact that it provides an inbuilt virtual os isincredible. try this one out sometime when you want to learn more aboutos research. on android though? on nintendo ds????</p><p>what's wrong with fork? some research:</p><ul><li><a href="https://www.microsoft.com/en-us/research/uploads/prod/2019/04/fork-hotos19.pdf">https://www.microsoft.com/en-us/research/uploads/prod/2019/04/fork-hotos19.pdf</a></li><li><a href="https://drewdevault.com/2018/01/02/The-case-against-fork.html">https://drewdevault.com/2018/01/02/The-case-against-fork.html</a> theOOM killer…….. KnightOS? the spawn model, in which a new process iscreated and kept in limbo, then you can change its environment, passit more file descriptors, and so forth until you're ready for theprocess to actually begin</li></ul></div></article></main><div class="article-rhs-container"><div class="article-rhs"><div class="sitemap-container"><span class="sitemap-title">In this article</span><table class="sitemap"><tr><td><a href="/journals/2021-01-04.html#1600-various-thoughts">1600-various-thoughts</a></td></tr><tr><td><a href="/journals/2021-01-04.html#whats-wrong-with-posix-io">whats-wrong-with-posix-io</a></td></tr><tr><td><a href="/journals/2021-01-04.html#partial-rebuttal-of-the-previous-by-robb-a-plan9-author">partial-rebuttal-of-the-previous-by-robb-a-plan9-author</a></td></tr><tr><td><a href="/journals/2021-01-04.html#the-reddit-thread-about-rewriting-unix-like">the-reddit-thread-about-rewriting-unix-like</a></td></tr></table></div><div class="git-history-table-container"><span class="git-history-table-title">Revisions</span><table class="git-history-table"><tr><th>Date</th><th>Hash</th></tr><tbody><tr><td class="commit-date-tr">2023-02-22</td><td class="commit-link-tr"><a href="https://github.com/jakeisnt/wiki/blob/ea5044fc387f17e24dcab6f3873a541cd640bfa1//journals/2021-01-04.md">ea5044fc</a></td></tr></tbody></table></div><div class="prev-next-up-buttons-container">Navigation<table class="prev-next-up-buttons"><tr><td>Previous</td><td><a class="prev-button" href="/journals/2021-01-05.html">2021-01-05</a></td></tr><tr><td>Next</td><td><a class="next-button" href="/journals/2020-12-25.html">2020-12-25</a></td></tr><tr><td>Up</td><td><a class="up-button" href="/journals">journals</a></td></tr></table></div></div></div></div></body></html>