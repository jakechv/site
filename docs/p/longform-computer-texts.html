<html lang=en>
 <head>
  <meta charset=UTF-8>
  <title>Longform Computer Texts | Jake Chvatal</title>
  <link rel=stylesheet
        href=/home/jake/site/docs/style.css>
  <link rel=stylesheet
        href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/default.min.css>
  <script
          src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js></script>
  <script>hljs.highlightAll();</script>
 </head>
 <body>
  <main>
   <div class=sidebar>
    <a href=https://jake.isnt.online>~ </a>
   </div>
   <h1>Longform Computer Texts</h1>
   <p><span>Feed: Pascal&#39;s Scribbles</span>
   <p><span>Title: Long-form Texts on Interesting Details of Computers</span>
   <p><span>Date: Wed, 15 Apr 2020 18:00:00 -0400</span>
   <p><span>Link: https:</span><span>deterministic.space</span><span>
     several-months-of-reading-material.html</span>
   <p><span>It seems especially recently I’ve come across more and more long-form 
     texts</span>
   <p><span>(think: hour-long blog posts; free books; series of posts). I especially 
     like</span>
   <p><span>the ones that go into the very fine details of some niche topic and maybe 
     also</span>
   <p><span>ramble a bit about completely unrelated but highly entertaining asides. 
     And</span>
   <p><span>while I will probably never have enough time to read them all, I decided 
     to at</span>
   <p><span>least collect some of them here for future reference. I’ll do my best to 
     add</span>
   <p><span>summaries, and to update this list semi-regularly.</span>
   <p><span>Contents</span>
   <p><span> * “Learn Rust With Entirely Too Many Linked Lists” by Alexis 
     Beingessner[1]</span>
   <p><span> * “Programming Algorithms” by Vsevolod Domkin[2]</span>
   <p><span> * “Aspects of Rust” by multiple people[3]</span>
   <p><span> * “Reading files the hard way” by Amos Wenger[4]</span>
   <p><span> * “Making our own ping” by Amos Wenger[5]</span>
   <p><span> * “Making our own executable packer” by Amos Wenger[6]</span>
   <p><span> * “Parsing” by Aleksey Kladov[7]</span>
   <p><span> * “JavaScript Allongé” by Reg “raganwald” Braithwaite[8]</span>
   <p><span> * “Crafting Interpreters” by Robert Nystrom[9]</span>
   <p><span> * “A relatively simple Datalog engine in Rust” by Frank McSherry[10]</span>
   <p><span> * “Non-lexical lifetimes” by Niko Matsakis[11]</span>
   <p><span> * “Shifgrethor” by Without Boats[12]</span>
   <p><span> * “Rayon</span><span>Parallel Iterators” by Niko Matsakis[13]</span>
   <p><span> * “How Rust optimizes async</span><span>await” by Tyler Mandry[14]</span>
   <p><span> * “Writing an OS in Rust” by Philipp Oppermann[15]</span>
   <p><span> * “Learning Parser Combinators With Rust” by Bodil Stokke[16]</span>
   <p><span> * “Manish vs. ASCII” by Manish Goregaokar[17]</span>
   <p><span> * “The Wayland Protocol” by Drew DeVault[18]</span>
   <p><span>“Learn Rust With Entirely Too Many Linked Lists[19]” by Alexis 
     Beingessner</span>
   <p><span>(~180 pages; archived[20])</span>
   <p><span>The premise of this book is that writing a linked list is a beginner’s 
     exercise</span>
   <p><span>in C but quite difficult to get right in Rust. So it takes that as an</span>
   <p><span>opportunity to do just what the title says: It teaches you Rust by 
     implementing</span>
   <p><span>a linked list type in Rust, in five (as of April 2020) different ways.</span>
   <p><span>Niches: data structures; linked lists; rust; smart pointers</span>
   <p><span>Last update I saw: 2019-03-21</span>
   <p><span>“Programming Algorithms[21]” by Vsevolod Domkin</span>
   <p><span>(~300 pages; archived[22])</span>
   <p><span>Book covering a lot of different data structures and algorithms. “Its aim 
     is to</span>
   <p><span>systematically explain how to write efficient programs and, also, the 
     approaches</span>
   <p><span>and tools for determining why the program isn’t efficient enough.”</span>
   <p><span>Niches: data structures; algorithms; lisp</span>
   <p><span>Last update I saw: 2020-04-16</span>
   <p><span>“Aspects of Rust” by multiple people</span>
   <p><span>Several stand-alone posts by various people whose only connection is that 
     they</span>
   <p><span>cover nice aspects of Rust.</span>
   <p><span>Niches: rust</span>
   <p><span> 1.</span>
   <p><span> A half-hour to learn Rust[23] (archived[24])</span>
   <p><span> Whirlwind tour through Rust as a language by Amos Wenger.</span>
   <p><span> 2.</span>
   <p><span> Typed Key Pattern[25] (archived[26])</span>
   <p><span> By Aleksey Kladov.</span>
   <p><span> 3.</span>
   <p><span> The Secret Life of Cows[27] (archived[28])</span>
   <p><span> The Clone-on-Write smart pointer explained by yours truly.</span>
   <p><span> 4.</span>
   <p><span> Newtype Index Pattern[29] (archived[30])</span>
   <p><span> By Aleksey Kladov.</span>
   <p><span> 5.</span>
   <p><span> How to implement a trait for &amp;str and &amp;[&amp;str][31] 
     (archived[32])</span>
   <p><span> Some musing on traits and borrows by yours truly.</span>
   <p><span> 6.</span>
   <p><span> Declarative memory management[33] (archived[34])</span>
   <p><span> By Amos Wenger. Introducing the complexities of memory management and 
     the</span>
   <p><span> ways Rust tries to represent them in a nice roundabout way.</span>
   <p><span> 7.</span>
   <p><span> Return-type based dispatch[31] (archived[32])</span>
   <p><span> By yours. By specifying at some later point in the code which type you 
     want</span>
   <p><span> your function to return, the compiler can go back and fill in the 
     blanks.</span>
   <p><span> 8.</span>
   <p><span> Working with strings in Rust[35] (archived[36])</span>
   <p><span> By Amos Wenger. Following the memory management post, this looks at how</span>
   <p><span> strings are actually pretty complicated and what Rust does about them.</span>
   <p><span>“Reading files the hard way” by Amos Wenger</span>
   <p><span>Writing files seems like a solved problem. But that doesn’t mean we can’t 
     solve</span>
   <p><span>it again from scratch.</span>
   <p><span>Niches: POSIX; file systems; syscalls</span>
   <p><span> 1. Part 1 (node.js, C, rust, strace)[37] (archived[38])</span>
   <p><span> 2. Part 2 (x86 asm, linux kernel)[39] (archived[40])</span>
   <p><span> 3. Part 3 (ftrace, disk layouts, ext4)[41] (archived[42])</span>
   <p><span>“Making our own ping” by Amos Wenger</span>
   <p><span> 1. A short (and mostly wrong) history of computer networking[43] 
     (archived[44])</span>
   <p><span> 2. Windows dynamic libraries, calling conventions, and transmute[45]</span>
   <p><span> (archived[46])</span>
   <p><span> 3. FFI-safe types in Rust, newtypes and MaybeUninit[47] (archived[48])</span>
   <p><span> 4. Designing and implementing a safer API on top of LoadLibrary[49]</span>
   <p><span> (archived[50])</span>
   <p><span> 5. A simple ping library, parsing strings into IPv4 address[51] 
     (archived[52])</span>
   <p><span> 6. The builder pattern, and a macro that keeps FFI code DRY[53] 
     (archived[54])</span>
   <p><span> 7. Finding the default network interface through WMI[55] (archived[56])</span>
   <p><span> 8. Binding C APIs with variable-length structs and UTF-16[57] 
     (archived[58])</span>
   <p><span> 9. Consuming Ethernet frames with the nom crate[59] (archived[60])</span>
   <p><span>10. Improving error handling - panics vs. proper errors[61] 
     (archived[62])</span>
   <p><span>11. Parsing IPv4 packets, including numbers smaller than bytes[63]</span>
   <p><span>(archived[64])</span>
   <p><span>12. Parsing and serializing ICMP packets with cookie-factory.[65] 
     (archived[66])</span>
   <p><span>13. Crafting ARP packets to find a remote host’s MAC address[67] 
     (archived[68])</span>
   <p><span>14. Crafting ICMP-bearing IPv4 packets with the help of bitvec[69]</span>
   <p><span>(archived[70])</span>
   <p><span>“Making our own executable packer” by Amos Wenger</span>
   <p><span> 1. What’s in a Linux executable?[71] (archived[72])</span>
   <p><span> 2. Running an executable without exec[73] (archived[74])</span>
   <p><span> 3. Position-independent code[75] (archived[76])</span>
   <p><span> 4. ELF relocations[77] (archived[78])</span>
   <p><span> 5. The simplest shared library[79] (archived[80])</span>
   <p><span> 6. Loading multiple ELF objects[81] (archived[82])</span>
   <p><span> 7. Dynamic symbol resolution[83] (archived[84])</span>
   <p><span> 8. Dynamic linker speed and correctness[85] (archived[86])</span>
   <p><span> 9. GDB scripting and Indirect functions[87] (archived[88])</span>
   <p><span>10. Safer memory-mapped structures[89] (archived[90])</span>
   <p><span>11. More ELF relocations[91] (archived[92])</span>
   <p><span>12. A no_std Rust binary[93] (archived[94])</span>
   <p><span>13. Thread-local storage[95] (archived[96])</span>
   <p><span>“Parsing” by Aleksey Kladov</span>
   <p><span>Not a real series of articles but a collection of posts by someone whose 
     Github</span>
   <p><span>bio reads “Stuck writing parsers”.</span>
   <p><span>Niches: parsers</span>
   <p><span> 1. Modern Parser Generator[97] (archived[98])</span>
   <p><span> 2. Simple but Powerful Pratt Parsing[99] (archived[100])</span>
   <p><span> 3. From Pratt to Dijkstra[101] (archived[102])</span>
   <p><span>“JavaScript Allongé[103]” by Reg “raganwald” Braithwaite</span>
   <p><span>(~530 pages; archived[104])</span>
   <p><span>Niches: functional programming; obscure JavaScript</span>
   <p><span>Last update I saw: 2019-04-26</span>
   <p><span>“Crafting Interpreters[105]” by Robert Nystrom</span>
   <p><span>(~800 pages; archived[106])</span>
   <p><span>Last update I saw: 2020-04-05</span>
   <p><span>“A relatively simple Datalog engine in Rust[107]” by Frank McSherry</span>
   <p><span>(~20 pages; archived[108])</span>
   <p><span>Building a datalog engine in Rust.</span>
   <p><span>Niches: datalog</span>
   <p><span>“Non-lexical lifetimes” by Niko Matsakis</span>
   <p><span>One of the main features of the Rust language is the concept of ownership 
     and</span>
   <p><span>lifetimes. This series of posts by Niko Matsakis, one of the designers of 
     the</span>
   <p><span>Rust language, is about the theory and practical implementation of a 
     revamped</span>
   <p><span>and more complete way of this in the Rust compiler. It starts in early 
     2016 and</span>
   <p><span>goes all the way to after they feature landed (end of 2018).</span>
   <p><span> 1. Introduction[109] (archived[110])</span>
   <p><span> 2. Non-lexical lifetimes based on liveness[111] (archived[112])</span>
   <p><span> 3. Adding the outlives relation[113] (archived[114])</span>
   <p><span> 4. Using liveness and location[115] (archived[116])</span>
   <p><span> 5. Nested method calls via two-phase borrowing[117] (archived[118])</span>
   <p><span> 6. Draft RFC and prototype available[119] (archived[120])</span>
   <p><span> 7. An alias-based formulation of the borrow checker[121] (archived[122])</span>
   <p><span> 8. MIR-based borrow check (NLL) status update[123] (archived[124])</span>
   <p><span> 9. MIR-based borrowck is almost here[125] (archived[126])</span>
   <p><span>10. Interprocedural conflicts[127] (archived[128])</span>
   <p><span>11. Polonius and region errors[129] (archived[130])</span>
   <p><span>12. Polonius and the case of the hereditary harrop predicate[131]</span>
   <p><span>(archived[132])</span>
   <p><span>“Shifgrethor” by Without Boats</span>
   <p><span>A proposed API for a GC in Rust.</span>
   <p><span> 1. Garbage collection as a Rust library[133] (archived[134])</span>
   <p><span> 2. Notes on tracing garbage collectors[135] (archived[136])</span>
   <p><span> 3. Rooting[137] (archived[138])</span>
   <p><span> 4. Tracing[139] (archived[140])</span>
   <p><span>“Rayon</span><span>Parallel Iterators” by Niko Matsakis</span>
   <p><span>Niches: concurrency</span>
   <p><span> 1. Rayon: Data parallelism in Rust[141] (archived[142])</span>
   <p><span> 2. Parallel Iterators Part 1: Foundations[143] (archived[144])</span>
   <p><span> 3. Parallel Iterators Part 2: Producers[145] (archived[146])</span>
   <p><span> 4. Parallel Iterators, part 3: Consumers[147] (archived[148])</span>
   <p><span>“How Rust optimizes async</span><span>await” by Tyler Mandry</span>
   <p><span>Niches: compilers; memory layout</span>
   <p><span> 1. Part I[149] (archived[150])</span>
   <p><span> 2. Part II: Program analysis[151] (archived[152])</span>
   <p><span>“Writing an OS in Rust” by Philipp Oppermann</span>
   <p><span>Niches: operating systems, assembler</span>
   <p><span> 1. A Freestanding Rust Binary[153] (archived[154])</span>
   <p><span> 2. A Minimal Rust Kernel[155] (archived[156])</span>
   <p><span> 3. VGA Text Mode[157] (archived[158])</span>
   <p><span> 4. Testing[159] (archived[160])</span>
   <p><span> 5. CPU Exceptions[161] (archived[162])</span>
   <p><span> 6. Double Faults[163] (archived[164])</span>
   <p><span> 7. Hardware Interrupts[165] (archived[166])</span>
   <p><span> 8. Introduction to Paging[167] (archived[168])</span>
   <p><span> 9. Paging Implementation[169] (archived[170])</span>
   <p><span>10. Heap Allocation[171] (archived[172])</span>
   <p><span>11. Allocator Designs[173] (archived[174])</span>
   <p><span>12. Async</span><span>Await[175] (archived[176])</span>
   <p><span>“Learning Parser Combinators With Rust[177]” by Bodil Stokke</span>
   <p><span>(~60 pages; archived[178])</span>
   <p><span>Assuming you know Rust, this teaches you the fundamentals of parser 
     combinators</span>
   <p><span>in a very hands-on way.</span>
   <p><span>Niches: parsers</span>
   <p><span>“Manish vs. ASCII” by Manish Goregaokar</span>
   <p><span>Several posts on why assuming text is ASCII is unhelpful.</span>
   <p><span>Niches: unicode</span>
   <p><span> 1.</span>
   <p><span> Let’s Stop Ascribing Meaning to Code Points[179] (archived[180])</span>
   <p><span> tl;dr you should not index into a Unicode text, like, ever.</span>
   <p><span> 2.</span>
   <p><span> Breaking Our Latin-1 Assumptions[181] (archived[182])</span>
   <p><span> Examples for scripts</span><span>languages that really don’t work if you 
     assume you have</span>
   <p><span> ASCII text.</span>
   <p><span> 3.</span>
   <p><span> Picking Apart the Crashing iOS String[183] (archived[184])</span>
   <p><span> Fun analysis of a Unicode rendering bug that crashed iOS devices.</span>
   <p><span>“The Wayland Protocol[185]” by Drew DeVault</span>
   <p><span>(~156 pages; archived[186])</span>
   <p><span>“Wayland is the next-generation display server for Unix-like systems[…] 
     This</span>
   <p><span>book will help you establish a firm understanding of the concepts, 
     design, and</span>
   <p><span>implementation of [it]”.</span>
   <p><span>Niches: wayland; graphics; protocols; unix</span>
   <p><span>Links:</span>
   <p><span>[1]: </span><span>(link)</span>
   <p><span>[2]: </span><span>(link)</span>
   <p><span>[3]: </span><span>(link)</span>
   <p><span>[4]: </span><span>(link)</span>
   <p><span>[5]: </span><span>(link)</span>
   <p><span>[6]: </span><span>(link)</span>
   <p><span>[7]: </span><span>(link)</span>
   <p><span>[8]: </span><span>(link)</span>
   <p><span>[9]: </span><span>(link)</span>
   <p><span>[10]: </span><span>(link)</span>
   <p><span>[11]: </span><span>(link)</span>
   <p><span>[12]: </span><span>(link)</span>
   <p><span>[13]: </span><span>(link)</span>
   <p><span>[14]: </span><span>(link)</span>
   <p><span>[15]: </span><span>(link)</span>
   <p><span>[16]: </span><span>(link)</span>
   <p><span>[17]: </span><span>(link)</span>
   <p><span>[18]: </span><span>(link)</span>
   <p><span>[19]: </span><span>(link)</span>
   <p><span>[20]: </span><span>(link)</span>
   <p><span>[21]: </span><span>(link)</span>
   <p><span>[22]: </span><span>(link)</span>
   <p><span>[23]: </span><span>(link)</span>
   <p><span>[24]: </span><span>(link)</span>
   <p><span>[25]: </span><span>(link)</span>
   <p><span>[26]: </span><span>(link)</span>
   <p><span>[27]: </span><span>(link)</span>
   <p><span>[28]: </span><span>(link)</span>
   <p><span>[29]: </span><span>(link)</span>
   <p><span>[30]: </span><span>(link)</span>
   <p><span>[31]: </span><span>(link)</span>
   <p><span>[32]: </span><span>(link)</span>
   <p><span>[33]: </span><span>(link)</span>
   <p><span>[34]: </span><span>(link)</span>
   <p><span>[35]: </span><span>(link)</span>
   <p><span>[36]: </span><span>(link)</span>
   <p><span>[37]: </span><span>(link)</span>
   <p><span>[38]: </span><span>(link)</span>
   <p><span>[39]: </span><span>(link)</span>
   <p><span>[40]: </span><span>(link)</span>
   <p><span>[41]: </span><span>(link)</span>
   <p><span>[42]: </span><span>(link)</span>
   <p><span>[43]: </span><span>(link)</span>
   <p><span>[44]: </span><span>(link)</span>
   <p><span>[45]: </span><span>(link)</span>
   <p><span>[46]: </span><span>(link)</span>
   <p><span>[47]: </span><span>(link)</span>
   <p><span>[48]: </span><span>(link)</span>
   <p><span>[49]: </span><span>(link)</span>
   <p><span>[50]: </span><span>(link)</span>
   <p><span>[51]: </span><span>(link)</span>
   <p><span>[52]: </span><span>(link)</span>
   <p><span>[53]: </span><span>(link)</span>
   <p><span>[54]: </span><span>(link)</span>
   <p><span>[55]: </span><span>(link)</span>
   <p><span>[56]: </span><span>(link)</span>
   <p><span>[57]: </span><span>(link)</span>
   <p><span>[58]: </span><span>(link)</span>
   <p><span>[59]: </span><span>(link)</span>
   <p><span>[60]: </span><span>(link)</span>
   <p><span>[61]: </span><span>(link)</span>
   <p><span>[62]: </span><span>(link)</span>
   <p><span>[63]: </span><span>(link)</span>
   <p><span>[64]: </span><span>(link)</span>
   <p><span>[65]: </span><span>(link)</span>
   <p><span>[66]: </span><span>(link)</span>
   <p><span>[67]: </span><span>(link)</span>
   <p><span>[68]: </span><span>(link)</span>
   <p><span>[69]: </span><span>(link)</span>
   <p><span>[70]: </span><span>(link)</span>
   <p><span>[71]: </span><span>(link)</span>
   <p><span>[72]: </span><span>(link)</span>
   <p><span>[73]: </span><span>(link)</span>
   <p><span>[74]: </span><span>(link)</span>
   <p><span>[75]: </span><span>(link)</span>
   <p><span>[76]: </span><span>(link)</span>
   <p><span>[77]: </span><span>(link)</span>
   <p><span>[78]: </span><span>(link)</span>
   <p><span>[79]: </span><span>(link)</span>
   <p><span>[80]: </span><span>(link)</span>
   <p><span>[81]: </span><span>(link)</span>
   <p><span>[82]: </span><span>(link)</span>
   <p><span>[83]: </span><span>(link)</span>
   <p><span>[84]: </span><span>(link)</span>
   <p><span>[85]: </span><span>(link)</span>
   <p><span>[86]: </span><span>(link)</span>
   <p><span>[87]: </span><span>(link)</span>
   <p><span>[88]: </span><span>(link)</span>
   <p><span>[89]: </span><span>(link)</span>
   <p><span>[90]: </span><span>(link)</span>
   <p><span>[91]: </span><span>(link)</span>
   <p><span>[92]: </span><span>(link)</span>
   <p><span>[93]: </span><span>(link)</span>
   <p><span>[94]: </span><span>(link)</span>
   <p><span>[95]: </span><span>(link)</span>
   <p><span>[96]: </span><span>(link)</span>
   <p><span>[97]: </span><span>(link)</span>
   <p><span>[98]: </span><span>(link)</span>
   <p><span>[99]: </span><span>(link)</span>
   <p><span>[100]: </span><span>(link)</span>
   <p><span>[101]: </span><span>(link)</span>
   <p><span>[102]: </span><span>(link)</span>
   <p><span>[103]: </span><span>(link)</span>
   <p><span>[104]: </span><span>(link)</span>
   <p><span>[105]: </span><span>(link)</span>
   <p><span>[106]: </span><span>(link)</span>
   <p><span>[107]: </span><span>(link)</span>
   <p><span>[108]: </span><span>(link)</span>
   <p><span>[109]: </span><span>(link)</span>
   <p><span>[110]: </span><span>(link)</span>
   <p><span>[111]: </span><span>(link)</span>
   <p><span>[112]: </span><span>(link)</span>
   <p><span>[113]: </span><span>(link)</span>
   <p><span>[114]: </span><span>(link)</span>
   <p><span>[115]: </span><span>(link)</span>
   <p><span>[116]: </span><span>(link)</span>
   <p><span>[117]: </span><span>(link)</span>
   <p><span>[118]: </span><span>(link)</span>
   <p><span>[119]: </span><span>(link)</span>
   <p><span>[120]: </span><span>(link)</span>
   <p><span>[121]: </span><span>(link)</span>
   <p><span>[122]: </span><span>(link)</span>
   <p><span>[123]: </span><span>(link)</span>
   <p><span>[124]: </span><span>(link)</span>
   <p><span>[125]: </span><span>(link)</span>
   <p><span>[126]: </span><span>(link)</span>
   <p><span>[127]: </span><span>(link)</span>
   <p><span>[128]: </span><span>(link)</span>
   <p><span>[129]: </span><span>(link)</span>
   <p><span>[130]: </span><span>(link)</span>
   <p><span>[131]: </span><span>(link)</span>
   <p><span>[132]: </span><span>(link)</span>
   <p><span>[133]: </span><span>(link)</span>
   <p><span>[134]: </span><span>(link)</span>
   <p><span>[135]: </span><span>(link)</span>
   <p><span>[136]: </span><span>(link)</span>
   <p><span>[137]: </span><span>(link)</span>
   <p><span>[138]: </span><span>(link)</span>
   <p><span>[139]: </span><span>(link)</span>
   <p><span>[140]: </span><span>(link)</span>
   <p><span>[141]: </span><span>(link)</span>
   <p><span>[142]: </span><span>(link)</span>
   <p><span>[143]: </span><span>(link)</span>
   <p><span>[144]: </span><span>(link)</span>
   <p><span>[145]: </span><span>(link)</span>
   <p><span>[146]: </span><span>(link)</span>
   <p><span>[147]: </span><span>(link)</span>
   <p><span>[148]: </span><span>(link)</span>
   <p><span>[149]: </span><span>(link)</span>
   <p><span>[150]: </span><span>(link)</span>
   <p><span>[151]: </span><span>(link)</span>
   <p><span>[152]: </span><span>(link)</span>
   <p><span>[153]: </span><span>(link)</span>
   <p><span>[154]: </span><span>(link)</span>
   <p><span>[155]: </span><span>(link)</span>
   <p><span>[156]: </span><span>(link)</span>
   <p><span>[157]: </span><span>(link)</span>
   <p><span>[158]: </span><span>(link)</span>
   <p><span>[159]: </span><span>(link)</span>
   <p><span>[160]: </span><span>(link)</span>
   <p><span>[161]: </span><span>(link)</span>
   <p><span>[162]: </span><span>(link)</span>
   <p><span>[163]: </span><span>(link)</span>
   <p><span>[164]: </span><span>(link)</span>
   <p><span>[165]: </span><span>(link)</span>
   <p><span>[166]: </span><span>(link)</span>
   <p><span>[167]: </span><span>(link)</span>
   <p><span>[168]: </span><span>(link)</span>
   <p><span>[169]: </span><span>(link)</span>
   <p><span>[170]: </span><span>(link)</span>
   <p><span>[171]: </span><span>(link)</span>
   <p><span>[172]: </span><span>(link)</span>
   <p><span>[173]: </span><span>(link)</span>
   <p><span>[174]: </span><span>(link)</span>
   <p><span>[175]: </span><span>(link)</span>
   <p><span>[176]: </span><span>(link)</span>
   <p><span>[177]: </span><span>(link)</span>
   <p><span>[178]: </span><span>(link)</span>
   <p><span>[179]: </span><span>(link)</span>
   <p><span>[180]: </span><span>(link)</span>
   <p><span>[181]: </span><span>(link)</span>
   <p><span>[182]: </span><span>(link)</span>
   <p><span>[183]: </span><span>(link)</span>
   <p><span>[184]: </span><span>(link)</span>
  </main>
 </body>
</html>