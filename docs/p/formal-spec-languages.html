<html lang=en>
 <head>
  <meta charset=UTF-8>
  <title>Formal Specification Langauges | Jake Chvatal</title>
  <link rel=stylesheet
        href=/home/jake/site/docs/style.css>
  <link rel=stylesheet
        href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/default.min.css>
  <script
          src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js></script>
  <script>hljs.highlightAll();</script>
 </head>
 <body>
  <main>
   <div class=sidebar>
    <a href=https://jake.isnt.online>~ </a>
   </div>
   <h1>Formal Specification Langauges</h1>
   <section>
    <h2>From Hillel Wayne&#39;s writing</h2>
    <p><span>A notation to describe the design of a system without implementing it.</span>
    <p><span>Can test the *design* for bugs rather than the implementation.</span>
    <section>
     <h3>Examples</h3>
     <ul>
      <li><span> </span><span> :: The first specification language to reach widespread 
        use. Relies on set theory to describe states and schemas to describe behavior, 
        first catalogued as a way of managing &#39;data semantics&#39;.</span>
     </ul>
     <ul>
      <li><span> </span><span> :: A response to Z&#39;s complex syntax and tooling. 
        Alloy is an attempt to simplify both of these, specifying everything as either a 
        type signature or relationship between signatures.</span>
     </ul>
     <p><span> Alloy is popular for SAT problems and models; it easily visualizes 
       models to share properties with nontechnical people as well. This would be the 
       tool to try!</span>
     <ul>
      <li><span> </span><span> is a formal specification langauge used to model 
        concurrent and distributed systems; it&#39;s best respected as testable 
        pseudocode and is similar to the drawing of blueprints for complex software 
        systems.</span>
     </ul>
     <p><span> It is also designed to check liveness properties of systems.</span>
     <p><span> </span><span> has a good article on modeling a complex system in the 
       software development world with formal methods.</span>
     <ul>
      <li><span> Prism :: Used to model *probabilistic* specifications, in which 
        different things have different chances of happening and events are all 
        dependent. Its syntax is very restrictive in order to be tractable, but the 
        opportunity to model probabilistic systems is incredible.</span>
     </ul>
     <ul>
      <li><span> Spin :: As expressive as TLA+, but written to model network protocols.</span>
     </ul>
     <p><span>There are a lot more, but I&#39;ll investigate them further as I learn 
       more.</span>
    </section>
   </section>
   <section>
    <h2>Terms</h2>
    <ul>
     <li><span> Temporal logic :: Extending standard mathematical notation to allow 
       temporal logic to change over time.</span>
    </ul>
    <p><span> Temporal logic of actions is a subset of this concept that scales to 
      real world systems.</span>
    <ul>
     <li><span> Liveness properties :: Similar to the definition in the compiler 
       sphere, liveness properties are properties of systems that must </span><span>
       eventually</span><span> be true for the spec to be valid.</span>
    </ul>
   </section>
   <section>
    <h2>etc</h2>
    <p><span>https:</span><span>github.com</span><span>wimmers</span><span>munta</span>
    <p><span>https:</span><span>melcer.dev</span><span>projects.html</span>
    <p>
    <p>
    <p><span>http:</span><span>www.ccs.neu.edu</span><span>home</span><span>pete</span>
     <span>courses</span><span>Computer-Aided-Reasoning</span><span>2018-Fall</span>
   </section>
  </main>
 </body>
</html>