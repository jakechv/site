<!DOCTYPE html><html><head><meta charset="UTF-8" /><title>memory-safety | Jake Chvatal</title><meta content="width=device-width,initial-scale=1.0" name="viewport" /><meta content="memory-safety" property="og:title" /><meta content="website" property="og:type" /><meta content="https://jake.isnt.online" property="og:url" /><meta content="Jake Chvatal" property="og:site_name" /><meta content="hi" name="description" /><meta content="Operating Systems, webring, programming, languages" name="keywords" /><meta content="Jake Chvatal" name="author" /><meta content="index,follow" name="robots" /><meta content="#fff" name="theme-color" /><link href="/style.css" rel="stylesheet" /><script src="/lib.js"></script></head><body><div class="site-body"><div class="sidebar"><a href="/">jake.</a><a href="https://isnt.online"> ~ </a><span> / </span><a href="./index.html">pages</a><span> / </span><b>memory-safety</b></div><main><article class="wikipage"><h1 class="title-top">memory-safety</h1><div><p>Ideas and articles on memory safety.</p><p>We can design around it explicitly or implicitly in many ways, butsoftware developers must always be aware of the memory their systemuses.</p><p>Systems like Forth are interesting because they don't just abstract overthe stack machines - they <strong>are</strong> the stack machines. This means theygive the programmer direct, immediate knowledge of how much memorythey're using at a given time.</p><p>Type systems that encapsulate memory are interesting, but by comparisonfeel like a bit of a hack: we have some system A with some semantics,then we graft system A' over it by making some assumptions about systemA, then we enforce rules of system A' by enforcing some system B thatfeels unrelated to the domain A and the language for the domain A', butthat enables optimisations and these things. I'm not entirely sure howto express the feeling of fighting both against the type system'senforcement of memory and against the language itself, but it detersexperiments - and play is the point.</p><p><a href="https://verdagon.dev/blog/when-to-use-memory-safe-part-1">Safety in Non-Memory-SafeLanguages</a> isinteresting; it investigates different proposed solutions investigatedwhen abstracting over programming languages. To me, the design of a goodsolution has a lot to do with how developers think about what they'reusing - we want to give developers as much information at the top levelas possible while allowing them to choose to focus on some things butnot others at specific times (ideas vs. hardened systems vs.optimisations, while giving the programmer all the information abouttheir ideas, their interfaces and how their code compiles and interfaceswith the GC). GC obscures, and optimisation engineers for GC'd languagesare tweaking compiler flags, memorizing the bytecode generated byspecific functions, or rolling their own systems and toolchains toprovide new performance profiles for languages.</p><p>But becoming an expert on how a programming language is written tooptimise it feels like a violation of the abstraction boundary thelanguage was created to erect in the first place!</p><p>Mmapped memory management, though idiomatic on Unix systems, also feelslike a bit of a hack - it doesn't match the memory model of developers.Nobody wants to think about how much memory operation X occupies,allocate space for it, then execute the operation - they want to first accomplish the operation however they can, then revisit their work andapply optimisation constraints if we determine that this point in thecode is the bottleneck.</p><p><a href="https://verdagon.dev/blog/generational-references">GenerationalReferences</a> are newin Vale and seem to <em>feel</em> both safer and more optimal than currentsolutions. Absolutely worth learning more about. The fact that they'restrongly considering branch prediction optimisations here is a greatidea.</p><p><a href="https://www.reddit.com/r/ProgrammingLanguages/comments/i1s8m0/functional_programming_and_reference_counting/">Functional Programming and Reference Counting :ProgrammingLanguages</a>addresses functional programming reference counting techniques in lean;specifically, optimizing theorem proving.</p></div></article></main><div class="git-hist-table"><table><tbody><tr><td>2023-02-22</td><td><a href="https://github.com/jakeisnt/wiki/blob/ea5044fc387f17e24dcab6f3873a541cd640bfa1//home/jake/wiki/pages/memory-safety.md">ea5044fc</a></td></tr></tbody></table></div></div></body></html>