<html lang=en>
 <head>
  <meta charset=UTF-8>
  <meta charset=utf-8>
  <title>Strong Types, Weak Types | Jake Chvatal</title>
  <meta name=viewport
        content="width=device-width,initial-scale=1.0">
  <meta property=og:title
        content="Strong Types, Weak Types">
  <meta property=og:type content=website>
  <meta property=og:url
        content=https://jake.isnt.online>
  <meta property=og:image
        content="https://avatars0.githubusercontent.com/u/29869612?s=400&amp;u=32e0c272cbfcc32b8e9585f74ce57d197aa14fb0&amp;v=4">
  <meta property=og:site_name
        content="Jake Chvatal">
  <meta name=description content=Hi>
  <meta name=keywords
        content="Strong Types, Weak Types, webring, programming, languages">
  <meta name=author content="Jake Chvatal">
  <meta name=robots content=follow>
  <meta name=theme-color content=#fff>
  <link rel=icon type=image/x-icon
        href=/favicon.ico>
  <link sizes=180x180 rel=apple-touch-icon
        type=image/png href=/apple-touch-icon.png>
  <link sizes=32x32 rel=icon type=image/png
        href=/favicon-32x32.png>
  <link sizes=16x16 rel=icon type=image/png
        href=/favicon-16x16.png>
  <link rel=manifest href=/site.webmanifest>
  <link rel=stylesheet
        href=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/styles/default.min.css>
  <link rel=stylesheet href=/style.css>
  <script src=/lib.js></script>
  <script src=/lfmNowPlaying.js></script>
  <script
          src=https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.6.0/highlight.min.js></script>
  <script>hljs.highlightAll();</script>
 </head>
 <body>
  <div class=site-body id=site-body>
   <div class=sidebar>
    <a href=/index.html> jake.</a><a href=https://isnt.online> ~ </a><span> / </span>
    <a href=/pages/index.html>pages</a><span> / </span><b>Strong Types, Weak Types</b>
   </div>
   <main>
    <article class=wikipage>
     <h1 class=title-top>Strong Types, Weak Types</h1>
     <p><span>I love the way that programming languages make my brain feel, work and 
       tick.</span>
     <p><span>Programming is really just a conversation with the computer. The tools we 
       use to program, with varying degrees of success and autonomy, improve the flow 
       of this conversation.</span>
     <h2>Strong Types</h2>
     <p><span>When I&#39;m using a language like Rust, Haskell or ML, my conversation 
       with the computer is honestly frustrating. It feels a lot like talking to that 
       brilliant friend who always has a leg up on you, but in an intimidating rather 
       than an accessible way; the system you&#39;re talking to has all the answers, 
       and though you&#39;re not reasonably expected to hold your understanding of all 
       of them in your head, you&#39;re expected to accomodate them when the computer 
       uses those rules to validate your work. You&#39;re talking to someone who knows 
       all the rules, and - especially when learning - you only know some of them. The 
       computer screams at you when your impression of the rules doesn&#39;t align with 
       theirs, even if you weren&#39;t informed of those rules beforehand, so 
       you&#39;re prevented from trying things out before you can learn why those 
       decisions are poor.</span>
     <p><span>The pain of this experience is multiplied when using interactive theorem 
       provers based on type theory, like Lean or Coq. Suddenly you have this arcane 
       system of dependent typing rules, and you&#39;re to defeat them using a series 
       of tactics - macros for proof strategies obscuring their details, their thoughts 
       and feelings.</span>
     <p><span>These perspectives have their places. If I&#39;m working on a large 
       system with multiple people, I&#39;ll never be able to hold the whole program, 
       with all of its rules and conventions and idiosyncracies, in my brain, and 
       having the system provide me all of these arcane error messages at runtime is a 
       terrible experience; I can&#39;t possibly debug and derive all of the work that 
       my coworkers have constructed.</span>
     <p><span>This is precisely why management structures often administer practices at 
       scale; just like some procedure like lean six sigma or something, types allow us 
       to apply structure to the code, administering rules that impact the way that 
       others are able to interact with the code. In this way, types allow us to 
       facilitate conversations with one another in a way prose can&#39;t; if I 
       don&#39;t follow the rules of a Haskell program, the system will tell me, 
       reminding me that this type is maintaining this rule in this position and that I 
       must follow it or the system won&#39;t even accept my work. Comments can&#39;t 
       provide this level of interactivity - no matter how much prose I write, nothing 
       but a type will allow the computer to tell someone else that they aren&#39;t 
       following the rules I&#39;ve put in place when I left the codebase.</span>
     <p><span>Once you understand the rules, there is ideally this feeling of immersion 
       with your computer - you&#39;re telling it exactly what it wants as the model 
       living in your brain molds perfectly to the model projected by the machine, and 
       you update your model seamlessly as you absorb more and more of the codebase 
       isnto your mind. The complexity and ruleset is entirely captured in the types 
       and invariants of the system.</span>
     <p><span>Unfortunately, to get to this point requires a significant amount of 
       effort and labor - it&#39;s really difficult to learn to understand the rules of 
       an incredibly complex system! - and up until, and even when you&#39;ve reached 
       that point and have to pursue some update, you can continue to run into new 
       rulesets that you have to update your priors with; changing the world you have 
       to navigate and understand as you integrate the code of others, whether 
       libraries or new parts of the codebase. High school debate, with its thinly 
       veiled ad homenim attacks and strawman arguments and strangely radical 
       frameworks, was less frustrating than navigating the intricacies of many a 
       Haskell library.</span>
     <section
              id="(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)"></section>
     <h2>Weak Types, Free Types</h2>
     <p><span>In stark contrast to the discipline of types, lisp has no rules. You can 
       tell the computer what you want, no matter how crazy, and it&#39;ll just happen. 
       Write some parentheses, pass some functions as arguments, construct something at 
       the nth level of abstraction and it&#39;ll be callable five functions down the 
       stack without having to accomodate or constrain it with any system of types.</span>
     <p><span>Lisp and C (through Zig, my chosen successor to the language) both feel 
       this way, but on different axes. Lisp has an incredibly simple ruleset through 
       which you can do anything. Common Lisp has been stable for fourty years (before 
       Linux!), has trivial compatibility with C libraries and native code, and can do 
       anything at any level of abstraction; you don&#39;t have to think about</span>
     <p><span>This feels a bit like perfecting a home-cooked meal. The recipe goes out 
       the window, the rules are completely arbitrary, and you&#39;re throwing spices 
       into the mix as you go - &quot;let&#39;s try some coriander! how about using 
       caar instead of caddr here?&quot; - as you have a natural conversation with your 
       tool; no constraints, just you and your craft.</span>
     <p><span>There is almost this feeling of immersion with your computer</span>
     <section
              id="(NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL NIL)"></section>
     <h2>close</h2>
     <p><span>Ultimately, one feels adversarial while the other feels generative; 
       programming against a strongly typed system feels like an argument where you can 
       blame their rules or blame yourself, while programming in a lisp runs you into 
       errors that are entirely of your own design. The former allows you to utilize a 
       system, constructing a debate in which you compromise your model of the world 
       with theirs until you meld into some system amenable to both ideas. The latter 
       leaves you no such framework; it&#39;s entirely up to you to set up the 
       guardrails, establish the framework, and set up the principles under which we 
       construct our programming environment and world, and as such the fault is only 
       with the model you&#39;ve constructed yourself when things break down. Holding 
       and owning this complete model is such a beautiful thing.</span>
     <section id="(NIL NIL)"></section>
     <h2>talking</h2>
     <p><span>Programming is a conversation, and when you speak to your computer and 
       language and libraries you&#39;re talking to the people of the past who have 
       written the code, the libraries, the operating system, the *everything* for you. 
       Good or bad, interacting with a computer allows you to interact with everyone 
       who&#39;s built this tower of abstractions that gets you to this point. Building 
       more systems allows you to talk to more people. Daily I have conversations with 
       McCarthy, with Manolios, with Stallman, with Pottering (maybe unfortunately), 
       through the systems of theirs that I make considerable use of.</span>
     <section id="(NIL NIL)"></section>
    </article>
   </main>
   <div class=git-hist-table>
    <table>
     <tr>
      <th>History
     <tr>
      <td>2022-10-01
      <td><a
       href=https://github.com/jakeisnt/wiki/blob/086d9a206da3d5febc56e8156442abbc43de6be9//pages/strong-types-weak-types.org>
        086d9a2</a>
     <tr>
      <td>2022-10-01
      <td><a
       href=https://github.com/jakeisnt/wiki/blob/f370ca6ca6f7a822249999addc40be741bd0a010//pages/strong-types-weak-types.org>
        f370ca6</a>
     <tr>
      <td>2022-10-01
      <td><a
       href=https://github.com/jakeisnt/wiki/blob/99bc369b7d1c5c435e2c391e04fd90dad9b6aa47//pages/strong-types-weak-types.org>
        99bc369</a>
     <tr>
      <td>2022-10-01
      <td><a
       href=https://github.com/jakeisnt/wiki/blob/f7f8a90ee236ef630fcc914f6b73a51406844afd//pages/strong-types-weak-types.org>
        f7f8a90</a>
     
    </table>
   </div>
   <div class=checkbox-menu>
    <input type=checkbox id=hypothesis-checkbox
           checked onclick=toggleHypothesis();>
     hypothes.is
    
   </div>
  </div>
  <script>getNowPlaying()</script>
 </body>
</html>