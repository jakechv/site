<!DOCTYPE html><html><head><meta charset="utf-8"></meta><title>path.ts / Jake Chvatal</title><meta property="og:title" content="path.ts"></meta><meta property="og:type" content="website"></meta><meta property="og:url" content="https://jake.isnt.online"></meta><meta property="og:site_name" content="Jake Chvatal"></meta><meta name="keywords" content="jake"></meta><meta name="author" content="Jake Chvatal"></meta><meta name="robots" content="index,follow"></meta><meta name="description" content="hi"></meta><meta name="theme-color" media="(prefers-color-scheme: light)" content="white"></meta><meta name="theme-color" media="(prefers-color-scheme: dark)" content="#111"></meta><link rel="icon" type="image/x-icon" href="/Users/jake/Documents/personal/site/favicons/favicon.ico"></link><link rel="apple-touch-icon" href="/Users/jake/Documents/personal/site/favicons/apple-touch-icon.png"></link><link rel="stylesheet" type="text/css" href="/resources/style.css" id="/resources/style.css"></link><link rel="stylesheet" type="text/css" href="/resources/global.css" id="/resources/global.css"></link><script src="/resources/lib.js" id="/resources/lib.js" type="module"></script><link rel="stylesheet" type="text/css" href="/resources/elements.css" id="/resources/elements.css"></link><link rel="manifest" href="/resources/manifest.json"></link><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/nord.min.css" id="dark-theme-highlight"></link><link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-light.min.css" id="light-theme-highlight"></link><script src="https://unpkg.com/@highlightjs/cdn-assets@11.7.0/highlight.min.js" id="https://unpkg.com/@highlightjs/cdn-assets@11.7.0/highlight.min.js" type=""></script><script src="/resources/elements.js" id="/resources/elements.js" type="module" defer="true"></script></head><body><link rel="stylesheet" href="/components/Sidebar/sidebar.css"></link><div class="sidebar"><div class="url-path"><b>jake.</b><span> / </span><a href="https://jake.isnt.online/src/index.html">src</a><span> / </span><a href="https://jake.isnt.online/src/utils/index.html">utils</a><span> / </span><b>path.ts</b></div><script src="/components/ToggleDarkMode/toggle-dark-mode.js" type="module"></script><link rel="stylesheet" href="/components/ToggleDarkMode/toggle-dark-mode.css"></link><div class="toggle-dark-mode-container"><button class="toggle-dark-mode"></button></div></div><div class="site-body"><main><article class="wikipage"><h1 class="title-top">path.ts</h1><pre><code class="language-ts has-raw-code">import pathLibrary from &quot;path&quot;;
import { execSync } from &quot;./cmd&quot;;
import fs from &quot;fs&quot;;
import logger from &quot;./log&quot;;
import mime from &quot;mime&quot;;
import { Repo } from &quot;./git&quot;;

/**
 * If a path string has a postfixed slash, remove it.
 */
const removePostfixedSlash = (pathString: string) =&gt; {
  if (pathString[pathString.length - 1] === &quot;/&quot;) {
    return pathString.slice(0, pathString.length - 1);
  }

  return pathString;
};

/**
 * A Path is the path to a file or directory on a system.
 */
class Path {
  // These params are immutable, so it&#x27;s safe to store both
  // and access them directly.
  private pathArray: string[] = [];
  private pathString: string = &quot;&quot;;

  /**
   * Construct a Path.
   * Do not call this directly.
   *
   * Works for both relative and absolute paths, fixing them into absolute paths as needed.
   * this should only be called by the static methods.
   */
  constructor(pathString: string) {
    let normalizedPath = pathLibrary.normalize(pathString);

    if (!pathLibrary.isAbsolute(normalizedPath)) {
      normalizedPath = pathLibrary.resolve(process.cwd(), normalizedPath);
    }

    normalizedPath = removePostfixedSlash(normalizedPath);

    this.pathString = normalizedPath;
    this.pathArray = normalizedPath
      .split(&quot;/&quot;)
      .slice(1)
      .filter((p) =&gt; p.length);
  }

  /**
   * Create a path. Call this to make a path.
   * @param maybePathString either an existing Path or a string.
   */
  static create(maybePathString: Path | string) {
    if (typeof maybePathString === &quot;string&quot;) {
      return new Path(maybePathString);
    } else if (maybePathString instanceof Path) {
      return maybePathString;
    }

    throw new Error(
      `Path provided must be a string or Path, given ${maybePathString}`
    );
  }

  /**
   * Returns a new Path with the proper full path.
   */
  static fromUrl(url: string, websiteName: string, sourcePath: string) {
    return new Path(url.replace(websiteName, sourcePath));
  }

  toString() {
    return this.pathString;
  }

  /**
   * This path is equal to another path if they have the same pathString.
   * If the other path is a string, this is still true..
   * @param otherPath The other path to compare this path to.
   */
  equals(otherPath: Path | string) {
    return this.pathString === Path.create(otherPath).pathString;
  }

  /**
   * Get the name of this file, including the extension.
   */
  get name() {
    return this.pathArray[this.pathArray.length - 1];
  }

  /**
   * Get the mimeType of this file based on its path string.
   */
  get mimeType() {
    return mime.getType(this.pathString) || &quot;text/plain&quot;;
  }

  /**
   * Get this file&#x27;s extension.
   * If we don&#x27;t have an extension provided, we determine it from disk.
   */
  get extension(): string | null {
    // we always fetch [1], because if the file has multiple extensions
    // we ignore the second and only care about the first.
    const ext = pathLibrary.extname(this.pathString).split(&quot;.&quot;)[1] ?? null;

    if (ext) {
      return ext;
    } else if (this.exists() &amp;&amp; this.isDirectory()) {
      return &quot;dir&quot;;
    }

    return ext;
  }

  /**
   * Get the parent of this path.
   */
  get parent() {
    return Path.create(
      &quot;/&quot; + this.pathArray.slice(0, this.pathArray.length - 1).join(&quot;/&quot;)
    );
  }

  /**
   * Is this path the root path of the directory?
   */
  isRootPath() {
    return this.pathArray.length === 0;
  }

  /**
   * Fetch and construct the repo if we don&#x27;t have one yet.
   * Returns null if we can&#x27;t find a repo for the page.
   */
  private __repo(): Repo | null {
    if (this.isRootPath()) {
      return null;
    }

    if (!this.isDirectory()) {
      return this.parent.__repo();
    }

    const gitDir = this.join(&quot;/.git&quot;);

    if (gitDir.exists()) {
      return Repo.create(this);
    }

    return this.parent.__repo();
  }

  /**
   * Get the git repo that this path is a member of.
   */
  get repo() {
    if (!this.exists()) {
      return null;
    }

    const rootRepo = this.__repo();
    return rootRepo ?? undefined;
  }

  /**
   * Copy the file or directory at this path to another path.
   * If the path is not a subdir of this path, throw an error.
   */
  copy(fromPath: Path | string, toPath: Path | string) {
    const from = Path.create(fromPath);
    const to = Path.create(toPath);

    // TODO: this would be a good safeguard to add, but it doesn&#x27;t work?
    // if (!this.contains(from)) {
    //   throw new Error(
    //     `Cannot copy ${from.toString()} to ${to.toString()} because it is not a subdirectory of ${this.toString()}`
    //   );
    // }

    try {
      execSync(`cp -r ${from.pathString} ${to.pathString}`, {
        cwd: this.toString(),
      });
    } catch (e) {
      console.log(&quot;error copying directory&quot;, e);
    }
  }

  /**
   * Move the file or directory at this path to another path.
   * If the path is not a subdir of this path, throw an error.
   */
  move(
    fromPath: Path | string,
    toPath: Path | string,
    { force = false }: { force: boolean } = {
      force: false,
    }
  ) {
    console.log(&quot;moving from &quot;, { from: fromPath, to: toPath });

    try {
      // Avoid normalizing the paths by using the originals provided
      execSync(`rsync -av --delete ${fromPath} ${toPath}`, {
        cwd: this.toString(),
      });
    } catch (e) {
      console.log(&quot;error moving directory&quot;, e);
    }
  }

  /**
   * get this path&#x27;s position relative to another path or string
   * ASSUME that the other paths, if defined, are the prefix of this one.
   * REMOVE &#x27;maybeOtherPath&#x27; from this path&#x27;s string.
   * If &#x27;maypeReplaceWithPath&#x27; is defined, append it.
   */
  relativeTo(maybeOtherPath: Path | string, maybeReplaceWithPath = &quot;&quot;) {
    const otherPath = Path.create(maybeOtherPath);
    const replaceWith = maybeReplaceWithPath.toString();

    if (!this.pathString.startsWith(otherPath.toString())) {
      throw new Error(
        `Path we are removing is no present on the current path. Was looking for path: ${this.pathString} relative to ${maybeOtherPath}`
      );
    }

    let resultingPathString = this.pathString;
    if (otherPath) {
      resultingPathString = resultingPathString.replace(
        `${otherPath.toString()}`,
        &quot;&quot;
      );
    }

    if (maybeReplaceWithPath) {
      resultingPathString = replaceWith.toString() + resultingPathString;
    }

    return Path.create(resultingPathString);
  }

  /**
   * Does the file at this path exist?
   */
  exists() {
    return fs.existsSync(this.pathString);
  }

  /**
   * Replace the path&#x27;s extension with a new one.
   * @argument extension the extension WITHOUT a prefixed period
   */
  replaceExtension(extension: string) {
    let newPathWithExtension = this.pathString;
    if (!newPathWithExtension.includes(&quot;.&quot;) &amp;&amp; extension.length) {
      newPathWithExtension += `.${extension}`;
    } else {
      newPathWithExtension = newPathWithExtension.replace(
        /\.\S+$/,
        `.${extension}`
      );
    }
    return new Path(newPathWithExtension);
  }

  /**
   * Is this path a directory?
   */
  isDirectory({ noFSOperation } = { noFSOperation: false }) {
    if (noFSOperation) {
      const extension = this.pathString.split(&quot;.&quot;)[1];

      return extension ? false : true;
    }

    if (!this.exists()) {
      throw new Error(
        `Cannot check if a path is a directory if it doesn&#x27;t exist. Was looking for path: ${this.pathString}`
      );
    }

    return fs.lstatSync(this.pathString).isDirectory();
  }

  // read this path as a utf8 string
  readString() {
    return fs.readFileSync(this.pathString, &quot;utf8&quot;);
  }

  /**
   * Write a string to the file at this path,
   * creating the file if it doesn&#x27;t exist.
   *
   */
  writeString(str: string) {
    this.make();
    fs.writeFileSync(this.pathString, str);
  }

  readBinary() {
    // const chunks = [];
    let buffer;

    // const readStream = fs.createReadStream(this.pathString);
    // readStream.on(&#x27;data&#x27;, (chunk) =&gt; {
    //   chunks.push(chunk);
    // });

    // readStream.on(&#x27;end&#x27;, () =&gt; {
    //   buffer = Buffer.concat(chunks);
    // });

    // while (!buffer) {
    // }
    return buffer;
  }

  writeBinary() {
    // const outStream = fs.createWriteStream(outPath);
    // inStream.pipe(outStream);
    // TODO
    // await new Promise((resolve) =&gt; {
    //   outStream.on(&#x27;close&#x27;, resolve);
    // });
  }

  /**
   * Read an entire directory, returning all of the paths in the directory.
   */
  readDirectory() {
    if (!this.isDirectory()) {
      throw new Error(
        `Cannot read directory &#x27;${this.pathString}&#x27; because it is not a directory`
      );
    }

    let normalizedPathString = this.pathString;

    // if the path doesn&#x27;t end in a slash, add one
    if (normalizedPathString[normalizedPathString.length - 1] !== &quot;/&quot;) {
      normalizedPathString += &quot;/&quot;;
    }

    return fs
      .readdirSync(normalizedPathString)
      .map((fileName) =&gt; new Path(`${normalizedPathString}${fileName}`));
  }

  /**
   * Join the provided next part of the path to this path,
   * producing the conjunction of the two.
   */
  join(nextPart: Path | string) {
    logger.file(&quot;Joining path&quot;, this.pathString, &quot;with&quot;, nextPart.toString());
    return new Path(this.pathString + nextPart.toString());
  }

  /**
   * Determines whether this path contains the other.
   * This implementation is a bit strange and title might not be accurate.
   */
  contains(maybeOtherPathString: Path | string) {
    const otherPath = Path.create(maybeOtherPathString);

    if (
      this.pathArray.length &gt; otherPath.pathArray.length ||
      this.pathString === otherPath.pathString
    ) {
      return false;
    }

    for (let i = 0; i &lt; this.pathArray.length; i++) {
      if (otherPath.pathArray[i] !== this.pathArray[i]) {
        return false;
      }
    }

    return true;
  }

  /**
   * Make this path exist, creating any parent directories along the way.
   * Assume the path is a file unless provided that it&#x27;s a directory.
   */
  make(settings?: { isDirectory?: boolean }) {
    const isDirectory = settings?.isDirectory;

    if (this.exists()) {
      console.log(&quot;.make: File already exists at path &quot;, this.pathString);
      return this;
    }

    // If this file is supposed to have a parent, then,
    // by definition, its parent must be a directory.
    // Make sure the parent directory exists.
    if (!this.parent.exists()) {
      console.log(
        &quot;The parent of this path&quot;,
        this.toString(),
        &quot;does not exist. Making it: &quot;,
        this.parent.toString()
      );

      this.parent.make({ isDirectory: true });
    }

    if (isDirectory) {
      console.log(&quot;Making directory at&quot;, this.pathString);
      fs.mkdirSync(this.pathString);
    } else {
      console.log(&quot;Making file at&quot;, this.pathString);
      fs.writeFileSync(this.pathString, &quot;&quot;);
    }

    return this;
  }

  /**
   * Watch this file for any action.
   * Invoke a callback listener if the file changes.
   *
   * NOTE: We currently don&#x27;t listen for file change events.
   * Those cause this to fail because we pass `this` through.
   */
  watch(callback: Function) {
    if (!this.exists()) {
      throw new Error(
        `Cannot watch path &#x27;${this.pathString}&#x27; because it does not exist`
      );
    }

    const watcher = fs.watch(this.pathString, (eventType, filename) =&gt; {
      // TODO: filename could be different if the file moves?
      callback(eventType, this);
    });

    return () =&gt; watcher.close();
  }
}

export { Path };
</code></pre></article></main><div class="article-rhs-container"><div class="article-rhs"><div class="git-history-table-container"><span class="git-history-table-title">Revisions</span><table class="git-history-table"><thead><tr><th>Date</th><th>Hash</th></tr></thead><tbody><tr><td class="commit-date-tr">2024-04-13</td><td class="commit-link-tr">b67bc56f</td></tr><tr><td class="commit-date-tr">2024-04-13</td><td class="commit-link-tr">17ceed04</td></tr><tr><td class="commit-date-tr">2024-04-13</td><td class="commit-link-tr">c56ed416</td></tr><tr><td class="commit-date-tr">2024-04-13</td><td class="commit-link-tr">838a868a</td></tr><tr><td class="commit-date-tr">2024-04-13</td><td class="commit-link-tr">4457e0b9</td></tr><tr><td class="commit-date-tr">2024-04-13</td><td class="commit-link-tr">a274b4c9</td></tr><tr><td class="commit-date-tr">2024-04-13</td><td class="commit-link-tr">24027a67</td></tr><tr><td class="commit-date-tr">2024-04-12</td><td class="commit-link-tr">52d9d7fe</td></tr><tr><td class="commit-date-tr">2024-04-12</td><td class="commit-link-tr">97a9e012</td></tr><tr><td class="commit-date-tr">2024-04-01</td><td class="commit-link-tr">a3c37e13</td></tr><tr><td class="commit-date-tr">2024-04-01</td><td class="commit-link-tr">3baa0660</td></tr><tr><td class="commit-date-tr">2024-04-01</td><td class="commit-link-tr">645f49d5</td></tr><tr><td class="commit-date-tr">2024-04-01</td><td class="commit-link-tr">390faed6</td></tr><tr><td class="commit-date-tr">2024-04-01</td><td class="commit-link-tr">110e0165</td></tr><tr><td class="commit-date-tr">2024-03-31</td><td class="commit-link-tr">6cca7a6a</td></tr><tr><td class="commit-date-tr">2024-03-31</td><td class="commit-link-tr">c64fbf31</td></tr><tr><td class="commit-date-tr">2024-03-31</td><td class="commit-link-tr">02dca1b8</td></tr><tr><td class="commit-date-tr">2024-03-31</td><td class="commit-link-tr">b0b5a058</td></tr><tr><td class="commit-date-tr">2024-03-31</td><td class="commit-link-tr">2e59e133</td></tr><tr><td class="commit-date-tr">2024-03-31</td><td class="commit-link-tr">dd2f23b0</td></tr><tr><td class="commit-date-tr">2024-03-31</td><td class="commit-link-tr">95fa0ee8</td></tr><tr><td class="commit-date-tr">2024-03-31</td><td class="commit-link-tr">4da03f6c</td></tr><tr><td class="commit-date-tr">2024-03-31</td><td class="commit-link-tr">baa38df5</td></tr><tr><td class="commit-date-tr">2024-03-31</td><td class="commit-link-tr">3e22c4b6</td></tr><tr><td class="commit-date-tr">2024-03-31</td><td class="commit-link-tr">dec57c39</td></tr><tr><td class="commit-date-tr">2024-03-31</td><td class="commit-link-tr">b3e98839</td></tr><tr><td class="commit-date-tr">2024-03-31</td><td class="commit-link-tr">692ce828</td></tr><tr><td class="commit-date-tr">2024-03-31</td><td class="commit-link-tr">9a544393</td></tr></tbody></table></div><div class="prev-next-up-buttons-container">Navigation<table class="prev-next-up-buttons"><tr><td>Next</td><td><a class="next-button" href="https://jake.isnt.online/src/utils/array.ts.html">array.ts</a></td></tr><tr><td>Up</td><td><a class="up-button" href="https://jake.isnt.online/src/utils.html">utils</a></td></tr></table></div></div></div></div></body></html>